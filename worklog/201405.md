**20140504**

1. 异步建立 TCP 连接，用 callback 处理错误。
  - 同步连接如果失败，会阻塞大约20秒（超时）才能获得返回值，不适合多设备批量操作。
2. 调整调用关系，不再用任务队列，读到任务后直接异步调用handler处理。
3. 帮助寻找Windows系统上的 split-horizon DNS 解决方案
  - 刘工在做的OA系统需要把一个域名根据用户的网段解析到内/外网不同的IP地址，Windows Server 2008自带的DNS服务不支持这个功能
  - 可以尝试免费软件： BIND

**20140505**

1. 对于 `设置调光模式` 类型的任务，生成一个 frame 并写到 socket
2. 把 `shared_ptr<Task>` 作为参数不断传递给 handler，完成任务后直接丢弃

**20140506**

1. 数据帧的写队列可以不断 push_back 新的待写帧，但是写完一帧后进入等待状态，直到这一帧被回复或是超时。
  - 这样就可以将回复和记录在数据帧中的 pending task 对应上了
  - 超时则在 pending task 中记录超时错误，并继续处理写队列
2. 写数据帧时，如果尚未连接，等待3秒后重试（共）1次。
3. 对收到的数据帧进行解析

**20140507**

1. 更新数据库的sql语句放在 task 中
  - 设置命令：在生成 task 对象时即可设置
  - 查询命令：在收到回复的时候设置
  - 上报及报警：在收到时设置
2. 修正网络通信逻辑中的问题，现在连续执行多个任务正常了
  - 同时执行多个 `async_connect` 会抛 exception
  - 加 `mutex` 避免这种情况
3. 增加如下任务类型的处理：
  - 控制器时间同步

**20140508**

1. 增加如下任务类型的处理：
  - 设置控制器时控调光计划
  - 清空控制器时控调光计划
2. 重写数据库模块，用C API。
  - C++ connector 的 `getString` 时不时会crash，搜索后发现长度大于16的varchar会出现这个问题
  - 网上提及的多种解决方法我都尝试了一遍，未能解决问题。方法包括
    1. 更改 `Code Generation`->`Runtime Library` 为 `/MD` 和 `/MDd`
    2. 从源码编译C++ Connector
    3. 用 `getBlob` 替代 `getString`
3. 从任务参数获取控制器MAC地址要去除重复的记录，以保证不给控制器发重复的数据帧。

**20140509**

1. 增加如下任务类型的处理：
  - 查询控制器状态
  - 查询控制器时控调光计划
  - 终端设备信息初始化
  - 终端设备信息删除
  - 终端设备调光
  - 终端设备组设置

**20140510**

1. 增加如下任务类型的处理：
  - 终端设备组删除
  - 查询终端设备状态量
  - 查询终端设备组号

**20140511**

1. 寻找 `CurrentTimestamp()` 中crash的原因。
  - `localtime()` 返回的 `struct std::tm*` 指针不需要我管理内存。
  - 显示的 `delete` 或是用 `unique_ptr`, `shared_ptr` 封装，就会重复释放堆上申请过的内存，导致crash。
2. 修正 `CurrentTimestamp()` 结果不完整的bug。
  - `operator<<` 对 `uint8_t` 的处理不是按数值类型的值写到流里的，加一个显示转换解决。
3. 解决 从数据库读取全部控制器MAC地址 结果为N个空字符串的问题。
  - binary类型的列 `row[0]` ，用 `std::string(row[0])` 得不到字符串值
  - 查询时使用 `HEX()` 函数把该列转成字符串再返回，解决。
  - 由于结果被用作 `std::stoull()` 的参数，原先传入 `""` 时，会抛 exception 提示无法转换成整形。
  - TODO 对 `std::stoull()` 要添加 `try...catch` 处理转换失败的情况。

**20140512**

1. 在 `socket.write()` 之前，检查是否已经完成建立连接。
2. 对各种任务类型，检查发送的数据帧内容是否与通信协议一致。
3. 完成的任务，从 `TaskTodo` 删除，连同返回值和错误信息一同写到 `TaskDone`，完成时间由数据库自动填当前时间。
4. 修正任务返回值被初始化为-1的问题
5. 修正 `GetDevicesOnController()` 返回为空的问题
6. 修正对一切binary类型数据库读取的问题，加 `HEX()`。
7. 修正MAC地址转换成16进制字符串被截断的问题。
8. 修正设置组和清除组的空指针问题。

**20140513**

1. 修正厂商信息UTF16字符乱码问题。
2. 修正设置组亮度失败的问题。

**20140514**

1. 修正查询终端设备组号结果有位移的问题。
2. 重构代码，将重复逻辑提取成工具函数，代码行数从3249减少到2880 (-11.3%)，保持功能不变。
3. 修正查询终端设备状态，多执行一次循环体的问题。（Log中发现原先将crc16的2字节读作了不支持的状态类型。）
4. 对各种 `std::stoull` 之类的转换，处理转换失败抛出的异常，并设置task的返回值和错误信息
5. 设置命令成功后不立即更新数据库。
6. 定时查询控制器、设备状态。
7. 增加如下任务类型的处理：
  - 终端设备调光渐变时间设置
  - 终端设备上电亮度值设置
  - 终端设备最大亮度值设置
  - 终端设备最小亮度值设置
  - 终端设备故障亮度值设置
  - 终端设备调光系数设置

**20140515**

1. 定时操作间隔设为0时，禁用定时操作
2. 调整Release版本log输出内容，console显示接受任务和完成任务的记录
3. 读socket的回调函数增加socket被关闭的处理，修复死循环一直读到0字节并报错的问题。
4. 更新 `ControllerStatus.CommState`
  - 连上或读写成功时置1
  - 连不上或读写超时置0
5. 增加socket重连功能
  - 对socket的读写如果得到错误表明对方已经断开，下一次任务处理会重新尝试连接。
6. 稳定性测试
  - 连续运行2小时，通信正常（每10秒定时查询控制器状态，每20秒定时查询全部灯状态）
  - CPU占用 0%~13% 全部时间消耗在外部函数上（申请string内存的系统调用、网络通信、数据库查询）
  - 内存占用 1596K~1820K 生成的对象用shared_ptr管理，任务完成后全部空间会自动释放
7. InstallShield项目，生成安装文件，包含程序、配置和依赖的libmysql.dll。
8. Doxygen文档，chm & pdf。

**20140516**

1. 调试时控调光计划的设置与查询
2. 调整数据库设计，允许同一控制器对应多条时控调光计划。
3. 解决首次连接设备耗时4秒的问题
  - `boost::asio::ip::tcp::resolver::resolve()` 解析 `IP:port` 地址耗时长
  - 限制只解析IPv4地址，函数就很快返回了

**20140517**

1. 更新文档

**20140519**

1. 数据库新增 `Firmware` 表
2. 约定固件升级任务参数格式
3. 开始实现设备固件升级功能

**20140520**

1. 实现如下控制逻辑
  - 进入终端固件升级模式
  - 下载终端固件信息
  - 下载升级包到控制器
  - 下载升级包到终端
  - 退出升级模式
2. 添加定时任务时，计算并填写MD5一列

**20140521**

1. 调试终端固件升级功能
  - 协议限制升级包每帧内容最多64KB，硬件上目前限制在1.5K左右
  - 通信程序目前取1KB为分断大小
  - 协议4.7.3中硬件响应帧的数据只确认上一帧收到的字节数，不是总数
  - 硬件目前只支持给广播地址升级固件

**20140522**

1. 终端固件升级功能完成
2. 清空时控调光计划稳定了（此前有挺大概率收不到回复）
3. 实现重启控制器指令发送
4. 读写逻辑分离，读始终是不阻塞的

**20140523**

1. 通信程序持续更新数据库 `SystemConfig.LastServerActivity` 字段，前台据此判断通信程序的运行状况。
2. 修正一部分对终端的操作命令，遇到错误但返回值是0的问题。
3. 实现设备恢复出厂功能。
4. 数据库查询增加结果为空指针的检查。
5. 重构数据库查询代码，将 `int` 和 `std::string` 类型的查询逻辑提取为工具函数，消除重复代码。

**20140526**

1. 开始写模拟控制器，用于压力测试。
  - 仅响应查状态/查设备状态两种指令

**20140527**

1. 模拟控制器
  - Python实现TCP Server，监听指定端口
2. Keepalive功能

**20140528**

1. 测试keepalive
2. 理清重写读数据帧逻辑的思路
  - 前一阶段的测试中，硬件有时返回的不是合法帧格式。最初服务器会崩溃，后来改写后做到丢弃数个帧之后能重新回到正常读写状态。
  - 但是依旧会有一个或几个合法帧随着非法帧一起被抛弃掉了。考虑重新写一个读数据帧的逻辑，确保不被垃圾信息影响，收到所有正确的帧。

**20140529**

1. 重写读数据帧逻辑
  - 改写完成，还有些读写时序上的问题需要修正
2. 草拟校正项目计划

**TODO**

1. 重构 `controller_connectin_sh_tcp_.cc` 代码
  - 构建data数组时的重复N个 `num_to_bytes()` 考虑用循环代替。这需要把一系列状态类型加到容器里。
  - 归并同样宽度的状态量的处理，差别只在数据库的列名称，可用map来解决。
2. 读逻辑还是得重写，否则垃圾信息中的完整帧可能会被抛弃
3. 软件模拟20个控制器，每个控制器接100个灯，压力测试。
4. 校正项目计划书
